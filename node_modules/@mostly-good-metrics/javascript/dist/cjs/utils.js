"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateUUID = generateUUID;
exports.getISOTimestamp = getISOTimestamp;
exports.isValidEventName = isValidEventName;
exports.validateEventName = validateEventName;
exports.sanitizeProperties = sanitizeProperties;
exports.resolveConfiguration = resolveConfiguration;
exports.detectPlatform = detectPlatform;
exports.detectDeviceType = detectDeviceType;
exports.getOSVersion = getOSVersion;
exports.getDeviceModel = getDeviceModel;
exports.delay = delay;
exports.getLocale = getLocale;
exports.getTimezone = getTimezone;
const logger_1 = require("./logger");
const types_1 = require("./types");
/**
 * Generate a UUID v4 string.
 */
function generateUUID() {
    // Use crypto.randomUUID if available (modern browsers and Node.js 19+)
    if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
        return crypto.randomUUID();
    }
    // Fallback implementation
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
/**
 * Get the current timestamp in ISO8601 format.
 */
function getISOTimestamp() {
    return new Date().toISOString();
}
/**
 * Validate an event name.
 * Must match pattern: ^$?[a-zA-Z][a-zA-Z0-9_]*$
 * Max 255 characters.
 */
function isValidEventName(name) {
    if (!name || name.length > types_1.Constraints.MAX_EVENT_NAME_LENGTH) {
        return false;
    }
    return types_1.EVENT_NAME_REGEX.test(name);
}
/**
 * Validate an event name and throw if invalid.
 */
function validateEventName(name) {
    if (!name) {
        throw new types_1.MGMError('INVALID_EVENT_NAME', 'Event name is required');
    }
    if (name.length > types_1.Constraints.MAX_EVENT_NAME_LENGTH) {
        throw new types_1.MGMError('INVALID_EVENT_NAME', `Event name must be ${types_1.Constraints.MAX_EVENT_NAME_LENGTH} characters or less`);
    }
    if (!types_1.EVENT_NAME_REGEX.test(name)) {
        throw new types_1.MGMError('INVALID_EVENT_NAME', 'Event name must start with a letter (or $ for system events) and contain only alphanumeric characters and underscores');
    }
}
/**
 * Sanitize event properties by truncating strings and limiting depth.
 */
function sanitizeProperties(properties, maxDepth = types_1.Constraints.MAX_PROPERTY_DEPTH) {
    if (!properties || typeof properties !== 'object') {
        return undefined;
    }
    const sanitized = sanitizeValue(properties, 0, maxDepth);
    if (typeof sanitized === 'object' && sanitized !== null && !Array.isArray(sanitized)) {
        return sanitized;
    }
    return undefined;
}
/**
 * Recursively sanitize a property value.
 */
function sanitizeValue(value, depth, maxDepth) {
    // Null is valid
    if (value === null) {
        return null;
    }
    // Primitives
    if (typeof value === 'boolean' || typeof value === 'number') {
        return value;
    }
    // Strings - truncate if needed
    if (typeof value === 'string') {
        if (value.length > types_1.Constraints.MAX_STRING_PROPERTY_LENGTH) {
            logger_1.logger.debug(`Truncating string property from ${value.length} to ${types_1.Constraints.MAX_STRING_PROPERTY_LENGTH} characters`);
            return value.substring(0, types_1.Constraints.MAX_STRING_PROPERTY_LENGTH);
        }
        return value;
    }
    // Arrays
    if (Array.isArray(value)) {
        if (depth >= maxDepth) {
            logger_1.logger.debug(`Max property depth reached, omitting nested array`);
            return null;
        }
        return value.map((item) => sanitizeValue(item, depth + 1, maxDepth));
    }
    // Objects
    if (typeof value === 'object') {
        if (depth >= maxDepth) {
            logger_1.logger.debug(`Max property depth reached, omitting nested object`);
            return null;
        }
        const result = {};
        for (const [key, val] of Object.entries(value)) {
            result[key] = sanitizeValue(val, depth + 1, maxDepth);
        }
        return result;
    }
    // Unknown type - convert to null
    return null;
}
/**
 * Resolve configuration with defaults.
 */
function resolveConfiguration(config) {
    const maxBatchSize = Math.min(Math.max(config.maxBatchSize ?? types_1.DefaultConfiguration.maxBatchSize, types_1.Constraints.MIN_BATCH_SIZE), types_1.Constraints.MAX_BATCH_SIZE);
    const flushInterval = Math.max(config.flushInterval ?? types_1.DefaultConfiguration.flushInterval, types_1.Constraints.MIN_FLUSH_INTERVAL);
    const maxStoredEvents = Math.max(config.maxStoredEvents ?? types_1.DefaultConfiguration.maxStoredEvents, types_1.Constraints.MIN_STORED_EVENTS);
    return {
        apiKey: config.apiKey,
        baseURL: config.baseURL ?? types_1.DefaultConfiguration.baseURL,
        environment: config.environment ?? types_1.DefaultConfiguration.environment,
        maxBatchSize,
        flushInterval,
        maxStoredEvents,
        enableDebugLogging: config.enableDebugLogging ?? types_1.DefaultConfiguration.enableDebugLogging,
        trackAppLifecycleEvents: config.trackAppLifecycleEvents ?? types_1.DefaultConfiguration.trackAppLifecycleEvents,
        bundleId: config.bundleId ?? detectBundleId(),
        appVersion: config.appVersion ?? '',
        osVersion: config.osVersion ?? '',
        platform: config.platform ?? detectPlatform(),
        sdk: config.sdk ?? 'javascript',
        sdkVersion: config.sdkVersion ?? '',
        storage: config.storage,
        networkClient: config.networkClient,
        onError: config.onError,
    };
}
/**
 * Detect the bundle ID from the current environment.
 */
function detectBundleId() {
    // In browser, use the hostname
    if (typeof window !== 'undefined' && window.location) {
        return window.location.hostname;
    }
    // In Node.js, could use package.json name but that requires fs access
    return '';
}
/**
 * Detect the current platform.
 * Note: For React Native, the platform should be passed via config (ios/android).
 */
function detectPlatform() {
    // Check for Node.js
    if (typeof process !== 'undefined' && process.versions?.node) {
        return 'node';
    }
    // Default to web for browser environments
    return 'web';
}
/**
 * Detect the device type from user agent.
 */
function detectDeviceType() {
    if (typeof navigator === 'undefined' || !navigator.userAgent) {
        return 'unknown';
    }
    const ua = navigator.userAgent.toLowerCase();
    // Check for specific device types
    if (/tablet|ipad|playbook|silk/i.test(ua)) {
        return 'tablet';
    }
    if (/mobile|iphone|ipod|android.*mobile|blackberry|opera mini|opera mobi/i.test(ua)) {
        return 'phone';
    }
    if (/smart-tv|smarttv|googletv|appletv|hbbtv|pov_tv|netcast.tv/i.test(ua)) {
        return 'tv';
    }
    // Default to desktop for other browsers
    if (typeof window !== 'undefined') {
        return 'desktop';
    }
    return 'unknown';
}
/**
 * Get the OS version string.
 */
function getOSVersion() {
    if (typeof navigator === 'undefined' || !navigator.userAgent) {
        return '';
    }
    const ua = navigator.userAgent;
    // Try to extract OS version from user agent
    const patterns = [
        [/Windows NT ([\d.]+)/i, 'Windows'],
        [/Mac OS X ([\d_.]+)/i, 'macOS'],
        [/iPhone OS ([\d_]+)/i, 'iOS'],
        [/iPad.*OS ([\d_]+)/i, 'iPadOS'],
        [/Android ([\d.]+)/i, 'Android'],
        [/Linux/i, 'Linux'],
    ];
    for (const [pattern, osName] of patterns) {
        const match = ua.match(pattern);
        if (match) {
            const version = match[1]?.replace(/_/g, '.') ?? '';
            return version ? `${osName} ${version}` : osName;
        }
    }
    return '';
}
/**
 * Get the browser/device model.
 */
function getDeviceModel() {
    if (typeof navigator === 'undefined' || !navigator.userAgent) {
        return '';
    }
    const ua = navigator.userAgent;
    // Try to extract browser name and version
    const patterns = [
        [/Chrome\/([\d.]+)/i, 'Chrome'],
        [/Firefox\/([\d.]+)/i, 'Firefox'],
        [/Safari\/([\d.]+)/i, 'Safari'],
        [/Edge\/([\d.]+)/i, 'Edge'],
        [/MSIE ([\d.]+)/i, 'IE'],
        [/Trident.*rv:([\d.]+)/i, 'IE'],
    ];
    for (const [pattern, browserName] of patterns) {
        const match = ua.match(pattern);
        if (match) {
            return `${browserName} ${match[1]}`;
        }
    }
    return '';
}
/**
 * Delay execution for a specified number of milliseconds.
 */
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Get the user's locale.
 */
function getLocale() {
    if (typeof navigator !== 'undefined') {
        return navigator.language || 'en';
    }
    return 'en';
}
/**
 * Get the user's timezone.
 */
function getTimezone() {
    try {
        return Intl.DateTimeFormat().resolvedOptions().timeZone || '';
    }
    catch {
        return '';
    }
}
//# sourceMappingURL=utils.js.map