import { logger, setDebugLogging } from './logger';
import { createDefaultNetworkClient } from './network';
import { createDefaultStorage, persistence } from './storage';
import { SystemEvents, SystemProperties, } from './types';
import { delay, detectDeviceType, generateUUID, getDeviceModel, getISOTimestamp, getLocale, getOSVersion, getTimezone, resolveConfiguration, sanitizeProperties, validateEventName, } from './utils';
const FLUSH_DELAY_MS = 100; // Delay between batch sends
/**
 * Main client for MostlyGoodMetrics.
 * Use the static `configure` method to initialize, then use static methods or the instance.
 */
export class MostlyGoodMetrics {
    /**
     * Private constructor - use `configure` to create an instance.
     */
    constructor(config) {
        this.flushTimer = null;
        this.isFlushingInternal = false;
        this.lifecycleSetup = false;
        this.handleVisibilityChange = () => {
            if (document.hidden) {
                // App backgrounded
                this.track(SystemEvents.APP_BACKGROUNDED);
                void this.flush(); // Flush when going to background
            }
            else {
                // App foregrounded
                this.track(SystemEvents.APP_OPENED);
            }
        };
        this.handleBeforeUnload = () => {
            // Best-effort flush using sendBeacon if available
            this.flushWithBeacon();
        };
        this.handlePageHide = () => {
            // Best-effort flush using sendBeacon if available
            this.flushWithBeacon();
        };
        this.config = resolveConfiguration(config);
        this.sessionIdValue = generateUUID();
        // Set up logging
        setDebugLogging(this.config.enableDebugLogging);
        // Initialize storage
        this.storage = this.config.storage ?? createDefaultStorage(this.config.maxStoredEvents);
        // Initialize network client
        this.networkClient = this.config.networkClient ?? createDefaultNetworkClient();
        logger.info(`MostlyGoodMetrics initialized with environment: ${this.config.environment}`);
        // Start auto-flush timer
        this.startFlushTimer();
        // Set up lifecycle tracking
        if (this.config.trackAppLifecycleEvents) {
            this.setupLifecycleTracking();
        }
    }
    /**
     * Configure and initialize the SDK.
     * Returns the singleton instance.
     */
    static configure(config) {
        if (!config.apiKey) {
            throw new Error('API key is required');
        }
        if (MostlyGoodMetrics.instance) {
            logger.warn('MostlyGoodMetrics.configure called multiple times. Using existing instance.');
            return MostlyGoodMetrics.instance;
        }
        MostlyGoodMetrics.instance = new MostlyGoodMetrics(config);
        return MostlyGoodMetrics.instance;
    }
    /**
     * Get the shared instance, or null if not configured.
     */
    static get shared() {
        return MostlyGoodMetrics.instance;
    }
    /**
     * Check if the SDK has been configured.
     */
    static get isConfigured() {
        return MostlyGoodMetrics.instance !== null;
    }
    /**
     * Reset the SDK (primarily for testing).
     */
    static reset() {
        if (MostlyGoodMetrics.instance) {
            MostlyGoodMetrics.instance.destroy();
            MostlyGoodMetrics.instance = null;
        }
    }
    // ============================================================
    // Static convenience methods (delegate to shared instance)
    // ============================================================
    /**
     * Track an event with the given name and optional properties.
     */
    static track(name, properties) {
        MostlyGoodMetrics.instance?.track(name, properties);
    }
    /**
     * Identify the current user.
     */
    static identify(userId) {
        MostlyGoodMetrics.instance?.identify(userId);
    }
    /**
     * Reset user identity.
     */
    static resetIdentity() {
        MostlyGoodMetrics.instance?.resetIdentity();
    }
    /**
     * Flush pending events to the server.
     */
    static flush() {
        return MostlyGoodMetrics.instance?.flush() ?? Promise.resolve();
    }
    /**
     * Start a new session.
     */
    static startNewSession() {
        MostlyGoodMetrics.instance?.startNewSession();
    }
    /**
     * Clear all pending events.
     */
    static clearPendingEvents() {
        return MostlyGoodMetrics.instance?.clearPendingEvents() ?? Promise.resolve();
    }
    /**
     * Get the count of pending events.
     */
    static getPendingEventCount() {
        return MostlyGoodMetrics.instance?.getPendingEventCount() ?? Promise.resolve(0);
    }
    /**
     * Set a single super property that will be included with every event.
     */
    static setSuperProperty(key, value) {
        MostlyGoodMetrics.instance?.setSuperProperty(key, value);
    }
    /**
     * Set multiple super properties at once.
     */
    static setSuperProperties(properties) {
        MostlyGoodMetrics.instance?.setSuperProperties(properties);
    }
    /**
     * Remove a single super property.
     */
    static removeSuperProperty(key) {
        MostlyGoodMetrics.instance?.removeSuperProperty(key);
    }
    /**
     * Clear all super properties.
     */
    static clearSuperProperties() {
        MostlyGoodMetrics.instance?.clearSuperProperties();
    }
    /**
     * Get all current super properties.
     */
    static getSuperProperties() {
        return MostlyGoodMetrics.instance?.getSuperProperties() ?? {};
    }
    // ============================================================
    // Instance properties
    // ============================================================
    /**
     * Get the current user ID.
     */
    get userId() {
        return persistence.getUserId();
    }
    /**
     * Get the current session ID.
     */
    get sessionId() {
        return this.sessionIdValue;
    }
    /**
     * Check if a flush operation is in progress.
     */
    get isFlushing() {
        return this.isFlushingInternal;
    }
    /**
     * Get the resolved configuration.
     */
    get configuration() {
        return { ...this.config };
    }
    // ============================================================
    // Instance methods
    // ============================================================
    /**
     * Track an event with the given name and optional properties.
     */
    track(name, properties) {
        try {
            validateEventName(name);
        }
        catch (e) {
            logger.error(`Invalid event name: ${name}`, e);
            return;
        }
        const sanitizedProperties = sanitizeProperties(properties);
        const superProperties = persistence.getSuperProperties();
        // Merge properties: super properties < event properties < system properties
        // Event properties override super properties, system properties are always added
        const mergedProperties = {
            ...superProperties,
            ...sanitizedProperties,
            [SystemProperties.DEVICE_TYPE]: detectDeviceType(),
            [SystemProperties.DEVICE_MODEL]: getDeviceModel(),
            [SystemProperties.SDK]: this.config.sdk,
        };
        const event = {
            name,
            client_event_id: generateUUID(),
            timestamp: getISOTimestamp(),
            userId: this.userId ?? undefined,
            sessionId: this.sessionIdValue,
            platform: this.config.platform,
            appVersion: this.config.appVersion || undefined,
            osVersion: this.config.osVersion || getOSVersion() || undefined,
            environment: this.config.environment,
            locale: getLocale(),
            timezone: getTimezone(),
            properties: Object.keys(mergedProperties).length > 0 ? mergedProperties : undefined,
        };
        logger.debug(`Tracking event: ${name}`, event);
        // Store event asynchronously
        this.storage.store(event).catch((e) => {
            logger.error('Failed to store event', e);
        });
        // Check if we should flush due to batch size
        void this.checkBatchSize();
    }
    /**
     * Identify the current user.
     */
    identify(userId) {
        if (!userId) {
            logger.warn('identify called with empty userId');
            return;
        }
        logger.debug(`Identifying user: ${userId}`);
        persistence.setUserId(userId);
    }
    /**
     * Reset user identity.
     */
    resetIdentity() {
        logger.debug('Resetting user identity');
        persistence.setUserId(null);
    }
    /**
     * Start a new session.
     */
    startNewSession() {
        this.sessionIdValue = generateUUID();
        logger.debug(`Started new session: ${this.sessionIdValue}`);
    }
    /**
     * Flush pending events to the server.
     */
    async flush() {
        if (this.isFlushingInternal) {
            logger.debug('Flush already in progress');
            return;
        }
        this.isFlushingInternal = true;
        logger.debug('Starting flush');
        try {
            await this.performFlush();
        }
        finally {
            this.isFlushingInternal = false;
        }
    }
    /**
     * Clear all pending events.
     */
    async clearPendingEvents() {
        logger.debug('Clearing all pending events');
        await this.storage.clear();
    }
    /**
     * Get the count of pending events.
     */
    async getPendingEventCount() {
        return this.storage.eventCount();
    }
    /**
     * Set a single super property that will be included with every event.
     */
    setSuperProperty(key, value) {
        logger.debug(`Setting super property: ${key}`);
        persistence.setSuperProperty(key, value);
    }
    /**
     * Set multiple super properties at once.
     */
    setSuperProperties(properties) {
        logger.debug(`Setting super properties: ${Object.keys(properties).join(', ')}`);
        persistence.setSuperProperties(properties);
    }
    /**
     * Remove a single super property.
     */
    removeSuperProperty(key) {
        logger.debug(`Removing super property: ${key}`);
        persistence.removeSuperProperty(key);
    }
    /**
     * Clear all super properties.
     */
    clearSuperProperties() {
        logger.debug('Clearing all super properties');
        persistence.clearSuperProperties();
    }
    /**
     * Get all current super properties.
     */
    getSuperProperties() {
        return persistence.getSuperProperties();
    }
    /**
     * Clean up resources (stop timers, etc.).
     */
    destroy() {
        this.stopFlushTimer();
        this.removeLifecycleListeners();
        logger.debug('MostlyGoodMetrics instance destroyed');
    }
    // ============================================================
    // Private methods
    // ============================================================
    async checkBatchSize() {
        const count = await this.storage.eventCount();
        if (count >= this.config.maxBatchSize) {
            logger.debug('Batch size threshold reached, triggering flush');
            void this.flush();
        }
    }
    async performFlush() {
        let hasMoreEvents = true;
        while (hasMoreEvents) {
            const eventCount = await this.storage.eventCount();
            if (eventCount === 0) {
                logger.debug('No events to flush');
                break;
            }
            // Check rate limiting
            if (this.networkClient.isRateLimited()) {
                logger.debug('Rate limited, skipping flush');
                break;
            }
            const events = await this.storage.fetchEvents(this.config.maxBatchSize);
            if (events.length === 0) {
                break;
            }
            const payload = this.buildPayload(events);
            const result = await this.networkClient.sendEvents(payload, this.config);
            if (result.success) {
                logger.debug(`Successfully sent ${events.length} events`);
                await this.storage.removeEvents(events.length);
            }
            else {
                logger.warn(`Failed to send events: ${result.error.message}`);
                // Call onError callback if configured
                if (this.config.onError) {
                    try {
                        this.config.onError(result.error);
                    }
                    catch (e) {
                        logger.error('Error in onError callback', e);
                    }
                }
                if (!result.shouldRetry) {
                    // Drop events on non-retryable errors (4xx)
                    logger.warn('Dropping events due to non-retryable error');
                    await this.storage.removeEvents(events.length);
                }
                else {
                    // Keep events for retry on retryable errors
                    hasMoreEvents = false;
                }
            }
            // Small delay between batches to avoid overwhelming the server
            await delay(FLUSH_DELAY_MS);
        }
    }
    buildPayload(events) {
        const context = {
            platform: this.config.platform,
            appVersion: this.config.appVersion || undefined,
            osVersion: this.config.osVersion || getOSVersion() || undefined,
            userId: this.userId ?? undefined,
            sessionId: this.sessionIdValue,
            environment: this.config.environment,
            locale: getLocale(),
            timezone: getTimezone(),
        };
        return { events, context };
    }
    startFlushTimer() {
        if (this.flushTimer) {
            return;
        }
        this.flushTimer = setInterval(() => {
            void this.flush();
        }, this.config.flushInterval * 1000);
        logger.debug(`Started flush timer (${this.config.flushInterval}s interval)`);
    }
    stopFlushTimer() {
        if (this.flushTimer) {
            clearInterval(this.flushTimer);
            this.flushTimer = null;
            logger.debug('Stopped flush timer');
        }
    }
    setupLifecycleTracking() {
        if (this.lifecycleSetup) {
            return;
        }
        if (typeof window === 'undefined' || typeof document === 'undefined') {
            logger.debug('Not in browser environment, skipping lifecycle tracking');
            return;
        }
        this.lifecycleSetup = true;
        // Track app installed/updated
        this.trackInstallOrUpdate();
        // Track app opened
        this.trackAppOpened();
        // Track visibility changes (background/foreground)
        document.addEventListener('visibilitychange', this.handleVisibilityChange);
        // Flush on page unload
        window.addEventListener('beforeunload', this.handleBeforeUnload);
        window.addEventListener('pagehide', this.handlePageHide);
        logger.debug('Lifecycle tracking enabled');
    }
    removeLifecycleListeners() {
        if (typeof document !== 'undefined') {
            document.removeEventListener('visibilitychange', this.handleVisibilityChange);
        }
        if (typeof window !== 'undefined') {
            window.removeEventListener('beforeunload', this.handleBeforeUnload);
            window.removeEventListener('pagehide', this.handlePageHide);
        }
    }
    trackInstallOrUpdate() {
        const currentVersion = this.config.appVersion;
        const previousVersion = persistence.getAppVersion();
        if (!currentVersion) {
            // No version configured, skip install/update tracking
            return;
        }
        if (persistence.isFirstLaunch()) {
            // First launch ever - track install
            this.track(SystemEvents.APP_INSTALLED, {
                [SystemProperties.VERSION]: currentVersion,
            });
            persistence.setAppVersion(currentVersion);
        }
        else if (previousVersion && previousVersion !== currentVersion) {
            // Version changed - track update
            this.track(SystemEvents.APP_UPDATED, {
                [SystemProperties.VERSION]: currentVersion,
                [SystemProperties.PREVIOUS_VERSION]: previousVersion,
            });
            persistence.setAppVersion(currentVersion);
        }
        else if (!previousVersion) {
            // First time with version tracking
            persistence.setAppVersion(currentVersion);
        }
    }
    trackAppOpened() {
        this.track(SystemEvents.APP_OPENED);
    }
    flushWithBeacon() {
        // Use sendBeacon for reliable delivery during page unload
        if (typeof navigator === 'undefined' || !navigator.sendBeacon) {
            return;
        }
        // Note: This is a synchronous, best-effort send
        // We can't use async storage operations here, so we rely on
        // the regular flush mechanism for most events
        logger.debug('Page unloading, attempting beacon flush');
    }
}
MostlyGoodMetrics.instance = null;
//# sourceMappingURL=client.js.map